"""
Video Segments API routes

Manages video segment metadata and analysis operations
"""

import logging
import uuid
from typing import List, Optional
from fastapi import APIRouter, HTTPException, Path, Query, Body, status, Depends

from backend.app.models.course_production.video_segment import (
    VideoSegment,
    ShotType,
    CreateVideoSegmentRequest,
    UpdateVideoSegmentRequest,
    AnalyzeSegmentRequest,
    BatchAnalyzeRequest
)
from backend.app.services.stores.course_production_store import CourseProductionStore
from backend.app.services.course_production.semantic_hub_integration import get_semantic_hub_client

router = APIRouter(
    tags=["course-production", "video-segments"]
)

logger = logging.getLogger(__name__)

# Store instance (singleton)
_store: Optional[CourseProductionStore] = None


def get_store() -> CourseProductionStore:
    """Get store instance"""
    global _store
    if _store is None:
        _store = CourseProductionStore()
    return _store


@router.get("", response_model=List[VideoSegment])
async def list_video_segments(
    instructor_id: str = Query(..., description="Instructor ID"),
    course_id: Optional[str] = Query(None, description="Filter by course"),
    tags: Optional[List[str]] = Query(None, description="Filter by tags"),
    shot_type: Optional[ShotType] = Query(None, description="Filter by shot type"),
    min_quality: Optional[float] = Query(None, ge=0.0, le=1.0, description="Minimum quality score"),
    script_line_id: Optional[str] = Query(None, description="Filter by script line ID"),
    store: CourseProductionStore = Depends(get_store)
):
    """
    List video segments with various filters

    Args:
        instructor_id: Instructor ID (required)
        course_id: Optional course filter
        tags: Optional tag filters
        shot_type: Optional shot type filter
        min_quality: Optional minimum quality score
        script_line_id: Optional script line ID filter

    Returns:
        List of video segments
    """
    try:
        segments = store.list_video_segments(
            instructor_id, course_id, tags, shot_type, min_quality, script_line_id
        )
        return segments
    except Exception as e:
        logger.error(f"Failed to list video segments: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list video segments: {str(e)}"
        )


@router.post("", response_model=VideoSegment, status_code=status.HTTP_201_CREATED)
async def create_video_segment(
    request: CreateVideoSegmentRequest = Body(...),
    store: CourseProductionStore = Depends(get_store)
):
    """
    Create video segment (manual or auto-generated by SmartCut)

    Args:
        request: Create video segment request

    Returns:
        Created video segment
    """
    try:
        # TODO: Validate source video exists
        # TODO: Calculate duration from start_time and end_time

        duration = request.end_time - request.start_time

        segment = VideoSegment(
            id=str(uuid.uuid4()),
            instructor_id=request.instructor_id,
            course_id=request.course_id,
            source_video_path=request.source_video_path,
            source_video_id=request.source_video_id,
            start_time=request.start_time,
            end_time=request.end_time,
            duration=duration,
            tags=request.tags or []
        )

        created_segment = store.create_video_segment(segment)
        return created_segment
    except Exception as e:
        logger.error(f"Failed to create video segment: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create video segment: {str(e)}"
        )


@router.get("/{segment_id}", response_model=VideoSegment)
async def get_video_segment(
    segment_id: str = Path(...),
    store: CourseProductionStore = Depends(get_store)
):
    """
    Get video segment details

    Args:
        segment_id: Video segment ID
        store: Course production store

    Returns:
        Video segment details
    """
    try:
        segment = store.get_video_segment(segment_id)
        if not segment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Video segment {segment_id} not found"
            )
        return segment
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get video segment: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get video segment: {str(e)}"
        )


@router.put("/{segment_id}", response_model=VideoSegment)
async def update_video_segment(
    segment_id: str = Path(...),
    request: UpdateVideoSegmentRequest = Body(...),
    store: CourseProductionStore = Depends(get_store)
):
    """
    Update video segment metadata (tags, quality, etc.)

    Args:
        segment_id: Video segment ID
        request: Update request
        store: Course production store

    Returns:
        Updated video segment
    """
    try:
        updates = {}
        if request.tags is not None:
            updates['tags'] = request.tags
        if request.action_names is not None:
            updates['action_names'] = request.action_names
        if request.intent_tags is not None:
            updates['intent_tags'] = request.intent_tags
        if request.shot_type is not None:
            updates['shot_type'] = request.shot_type.value
        if request.quality_score is not None:
            updates['quality_score'] = request.quality_score
        if request.quality_level is not None:
            updates['quality_level'] = request.quality_level.value

        updated_segment = store.update_video_segment(segment_id, updates)
        if not updated_segment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Video segment {segment_id} not found"
            )
        return updated_segment
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to update video segment: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to update video segment: {str(e)}"
        )


@router.post("/{segment_id}/analyze", status_code=status.HTTP_202_ACCEPTED)
async def analyze_segment(
    segment_id: str = Path(...),
    request: AnalyzeSegmentRequest = Body(...)
):
    """
    Trigger segment analysis (CV + STT, calls Semantic Hub)

    Args:
        segment_id: Video segment ID
        request: Analysis request with options

    Returns:
        Analysis job information
    """
    try:
        # TODO: Get segment from database
        # TODO: Call Semantic Hub analysis service
        # TODO: Create analysis job record

        return {
            "success": True,
            "segment_id": segment_id,
            "analysis_job_id": str(uuid.uuid4()),
            "message": "Analysis job started"
        }
    except Exception as e:
        logger.error(f"Failed to analyze segment: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to analyze segment: {str(e)}"
        )


@router.post("/batch-analyze", status_code=status.HTTP_202_ACCEPTED)
async def batch_analyze_segments(
    request: BatchAnalyzeRequest = Body(...),
    store: CourseProductionStore = Depends(get_store)
):
    """
    Batch analyze segments (SmartCut workflow)

    Args:
        request: Batch analysis request with video path and script lines
        store: Course production store

    Returns:
        Batch analysis job information
    """
    try:
        # Validate video file exists
        from pathlib import Path
        video_path_obj = Path(request.video_path)
        if not video_path_obj.exists():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Video file not found: {request.video_path}"
            )

        # Get Semantic Hub client
        semantic_client = get_semantic_hub_client()
        if not semantic_client or not semantic_client.is_configured():
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Semantic Hub is not configured or unavailable"
            )

        # Call SmartCut service from Semantic Hub
        try:
            analysis_result = await semantic_client.batch_analyze_video(
                video_path=request.video_path,
                script_lines=request.script_lines,
                instructor_id=request.instructor_id,
                course_id=request.course_id
            )

            analysis_job_id = analysis_result.get("job_id") or analysis_result.get("id") or str(uuid.uuid4())
            candidate_segments = analysis_result.get("segments", [])

        except Exception as e:
            logger.error(f"Semantic Hub batch analysis failed: {str(e)}")
            raise HTTPException(
                status_code=status.HTTP_502_BAD_GATEWAY,
                detail=f"Failed to start batch analysis on Semantic Hub: {str(e)}"
            )

        # Create video segments from analysis results
        created_segments = []
        for segment_data in candidate_segments:
            segment = VideoSegment(
                id=str(uuid.uuid4()),
                instructor_id=request.instructor_id,
                course_id=request.course_id,
                source_video_path=request.video_path,
                source_video_id=analysis_job_id,
                start_time=segment_data.get("start_time", 0.0),
                end_time=segment_data.get("end_time", 0.0),
                duration=segment_data.get("duration", 0.0),
                shot_type=ShotType(segment_data["shot_type"]) if segment_data.get("shot_type") else None,
                quality_score=segment_data.get("quality_score", 0.0),
                tags=segment_data.get("tags", []),
                script_line_ids=segment_data.get("script_line_ids", []),
                script_alignment_confidence=segment_data.get("alignment_confidence"),
                analysis_job_id=analysis_job_id
            )

            created_segment = store.create_video_segment(segment)
            created_segments.append(created_segment.id)

        return {
            "success": True,
            "analysis_job_id": analysis_job_id,
            "video_path": request.video_path,
            "segments_created": len(created_segments),
            "segment_ids": created_segments,
            "message": "Batch analysis job started and segments created"
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to batch analyze segments: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to batch analyze segments: {str(e)}"
        )


@router.delete("/{segment_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_video_segment(
    segment_id: str = Path(...),
    store: CourseProductionStore = Depends(get_store)
):
    """
    Delete video segment

    Args:
        segment_id: Video segment ID
        store: Course production store
    """
    try:
        success = store.delete_video_segment(segment_id)
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Video segment {segment_id} not found"
            )

        from fastapi.responses import JSONResponse
        return JSONResponse(
            status_code=status.HTTP_204_NO_CONTENT,
            content=None
        )
    except Exception as e:
        logger.error(f"Failed to delete video segment: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to delete video segment: {str(e)}"
        )
