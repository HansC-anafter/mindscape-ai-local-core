"""
Web Page Sandbox implementation

Manages dynamic web page projects with React components, page structure,
and deployment support. Includes Next.js project template for preview.
"""

from typing import Optional, Dict, Any
import logging
import json

from backend.app.services.sandbox.base_sandbox import BaseSandbox

logger = logging.getLogger(__name__)

# Next.js project template files
NEXTJS_TEMPLATE = {
    "package.json": json.dumps({
        "name": "mindscape-web-page",
        "version": "1.0.0",
        "private": True,
        "scripts": {
            "dev": "next dev",
            "build": "next build",
            "start": "next start",
            "lint": "next lint"
        },
        "dependencies": {
            "next": "14.0.4",
            "react": "^18",
            "react-dom": "^18",
            "three": "^0.160.0",
            "@react-three/fiber": "^8.15.12",
            "@react-three/drei": "^9.92.7"
        },
        "devDependencies": {
            "typescript": "^5",
            "@types/node": "^20",
            "@types/react": "^18",
            "@types/react-dom": "^18",
            "@types/three": "^0.160.0"
        }
    }, indent=2),
    "tsconfig.json": json.dumps({
        "compilerOptions": {
            "target": "es5",
            "lib": ["dom", "dom.iterable", "esnext"],
            "allowJs": True,
            "skipLibCheck": True,
            "strict": True,
            "noEmit": True,
            "esModuleInterop": True,
            "module": "esnext",
            "moduleResolution": "bundler",
            "resolveJsonModule": True,
            "isolatedModules": True,
            "jsx": "preserve",
            "incremental": True,
            "paths": {
                "@/*": ["./*"]
            }
        },
        "include": ["**/*.ts", "**/*.tsx"],
        "exclude": ["node_modules"]
    }, indent=2),
    "next.config.js": """/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  // Allow importing from parent directories
  transpilePackages: [],
}

module.exports = nextConfig
""",
    "app/layout.tsx": """import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'Mindscape Web Page',
  description: 'Generated by Mindscape AI',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="zh-TW">
      <body>{children}</body>
    </html>
  )
}
""",
    "app/globals.css": """* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
}
""",
    "app/page.tsx": """// This file will be replaced by pages/index.tsx content
// Default placeholder
export default function Home() {
  return (
    <main>
      <h1>Mindscape Web Page</h1>
      <p>Loading...</p>
    </main>
  )
}
""",
}


class WebPageSandbox(BaseSandbox):
    """
    Sandbox for web page projects

    Manages:
    - Page structure (spec/, hero/, sections/, pages/)
    - React components
    - Deployment configuration
    - Next.js project template for preview
    """

    def __init__(
        self,
        sandbox_id: str,
        sandbox_type: str,
        workspace_id: str,
        storage,
        metadata: Optional[Dict[str, Any]] = None
    ):
        super().__init__(sandbox_id, sandbox_type, workspace_id, storage, metadata)
        self.sandbox_type = "web_page"

    async def initialize_template(self) -> bool:
        """
        Initialize Next.js project template for preview support.

        Creates package.json, tsconfig.json, and basic Next.js structure.

        Returns:
            True if initialization successful, False otherwise
        """
        try:
            for file_path, content in NEXTJS_TEMPLATE.items():
                # Check if file already exists
                if not await self.file_exists(file_path):
                    await self.write_file(file_path, content)
                    logger.info(f"Created template file: {file_path}")

            logger.info(f"Initialized Next.js template for sandbox {self.sandbox_id}")
            return True

        except Exception as e:
            logger.error(f"Failed to initialize template: {e}")
            return False

    async def sync_pages_to_app(self) -> bool:
        """
        Sync pages/index.tsx to app/page.tsx for Next.js routing.

        Returns:
            True if sync successful, False otherwise
        """
        try:
            # Check if pages/index.tsx exists
            if await self.file_exists("pages/index.tsx"):
                content = await self.read_file("pages/index.tsx")
                await self.write_file("app/page.tsx", content)
                logger.info("Synced pages/index.tsx to app/page.tsx")
                return True
            return False
        except Exception as e:
            logger.error(f"Failed to sync pages: {e}")
            return False

    async def get_change_summary(
        self,
        from_version: Optional[str],
        to_version: Optional[str]
    ) -> str:
        """Get AI-generated summary of changes between versions"""
        from_files = await self.list_files(version=from_version)
        to_files = await self.list_files(version=to_version)

        from_paths = {f["path"] for f in from_files}
        to_paths = {f["path"] for f in to_files}

        added = to_paths - from_paths
        removed = from_paths - to_paths
        modified = from_paths & to_paths

        summary_parts = []
        if added:
            summary_parts.append(f"Added {len(added)} file(s)")
        if removed:
            summary_parts.append(f"Removed {len(removed)} file(s)")
        if modified:
            summary_parts.append(f"Modified {len(modified)} file(s)")

        return "; ".join(summary_parts) if summary_parts else "No changes"

    async def validate(self) -> Dict[str, Any]:
        """Validate web page sandbox structure"""
        errors = []
        warnings = []

        files = await self.list_files()
        file_paths = {f["path"] for f in files}

        required_dirs = ["spec", "hero", "sections", "pages"]
        for dir_name in required_dirs:
            has_files = any(f.startswith(f"{dir_name}/") for f in file_paths)
            if not has_files:
                warnings.append(f"Directory {dir_name}/ is empty")

        required_files = [
            "spec/site_structure.yaml",
            "spec/page.md",
        ]
        for req_file in required_files:
            if req_file not in file_paths:
                errors.append(f"Required file missing: {req_file}")

        return {
            "valid": len(errors) == 0,
            "errors": errors,
            "warnings": warnings,
        }

